"""
mc2hessian.py

This module containts the functionality to compute reduced set using the
`mc2hessian` (Appendix of `1505.06736 <http://arxiv.org/abs/1505.06736>`_)
and `SMPDF` <paper> algorithms.
"""

from validphys.lhio import hessian_from_lincomb
import numpy as np
import logging
import pandas as pd
import os
import hashlib
from validphys import lhaindex
from reportengine.checks import make_check
import shutil
from validphys.core import PDF
from reportengine.compat import yaml
import validphys.pdfgrids as pdfgrids
from validphys.pdfbases import check_basis, Basis
from validphys.gridvalues import grid_values
import hashlib


log = logging.getLogger(__name__)


class ActionError(Exception):
    pass


def check(check_func):
    def decorator(f):
        if not hasattr(f, "checks"):
            f.checks = []
        f.checks += [check_func]
        return f

    return decorator


def _mc2hname(prefix, pdf, group, config):
    return "_".join((prefix, str(pdf), str(group["Neig"])))


_namemap = {"mc2hessian": _mc2hname}


_nameoverride = {"mc2hessian": "mc2hname", "smpdf": "smpdfname"}


def gridnames(action, group):
    prefix = group["prefix"]
    if "grid_names" not in group:
        group["grid_names"] = {}
    for pdf in group["pdfsets"]:
        name_key = _nameoverride.get(action, None)
        if name_key in group:
            user_name = group[name_key]
            if isinstance(user_name, str):
                if len(group["pdfsets"]) == 1:
                    grid_name = user_name
                else:
                    raise ActionError(
                        (
                            "Ambiguous specification of name (%s) "
                            "for action "
                            "%s. Use a mapping to specify a name for "
                            "each input"
                        )
                        % (user_name, action)
                    )
            elif isinstance(user_name, dict):
                try:
                    grid_name = user_name[str(pdf)]
                except KeyError:
                    raise ActionError("No name specification for PDF '%s'" % pdf)
            else:
                raise ActionError("Invalid value for parameter %s" % name_key)
        # elif action in _namemap:
        #     grid_name = _namemap[action](prefix, pdf, group, config)
        else:
            grid_name = prefix + action + "_" + str(pdf)
        if lhaindex.isinstalled(grid_name):
            raise ActionError(
                "The grid '%s' "
                "that will be generated by the action '%s' "
                "is already installed in the LHAPDF path." % (grid_name, action)
            )
        # if grid_name in config._grid_names:
        #     raise ActionError("The grid %s would be generated multiple times." % grid_name)
        # config._grid_names.append(grid_name)
        group["grid_names"][(action, pdf)] = grid_name
    return group["grid_names"]


def get_X(pdf, Q=None, reshape=False, xgrid=None, fl=None, photon=False):
    # Step 1: create pdf covmat
    if Q is None:
        Q = pdf.QMin
    logging.debug("Building PDF matrix at %f GeV:" % Q)




    basis='flavour'
    if Q is None:
        Q = self.QMin
    if xgrid is None:
        xgrid = make_xgrid()
    #Allow tuples that can be saved in cache
    elif isinstance(xgrid, tuple):
        xgrid = make_xgrid(*xgrid)
    checked = check_basis(basis, fl)

    pdfGrid = pdfgrids.xplotting_grid(
        pdf, Q, xgrid=xgrid, basis=basis, flavours=fl)
    pdfGrid_values = pdfGrid.grid_values
    replicas = pdfGrid_values
    mean = pdfGrid_values.mean(axis=0)





    # mean, replicas = pdf.grid_values(Q, xgrid, fl, photon=photon)
    Xt = replicas - mean
    if reshape:
        Xt = Xt.reshape(Xt.shape[0], Xt.shape[1] * Xt.shape[2])
    return Xt.T


def compress_X(X, neig):
    U, s, V = np.linalg.svd(X, full_matrices=False)
    vec = V[:neig, :].T
    return vec


def _pdf_normalization(pdf):
    """Extract the quantity by which we have to divide the eigenvectors to
    get the correct errors, depending on the `ErrorType` of `pdf`."""
    nrep = len(pdf) - 1
    if pdf.ErrorType == "replicas":
        norm = np.sqrt(nrep - 1)
    elif pdf.ErrorType in ("hessian", "symmhessian"):
        norm = 1
    else:
        raise NotImplementedError(
            "SMPDF is not implemented for this type of " "PDF error: %s" % pdf.ErrorType
        )
    return norm


def mc2h_input_hash(pdf, Q, Neig):
    m=hashlib.sha1()
    hashstr = b"".join([m.digest(), float(Q).hex().encode(), hex(Neig).encode()])
    return hashlib.sha1(hashstr).hexdigest()


def check_lhawrite(action, group, config):
    path = lhaindex.get_lha_datapath()
    if not os.access(path, os.W_OK):
        raise ActionError(
            "Cannot write in LHAPDF path: %s. " "Unable to complete action %s" % (path, action)
        )


def install_grids(gridnames, output_path):
    dest = lhaindex.get_lha_datapath()
    for name in gridnames.values():
        shutil.copytree(os.path.join(output_path, name), os.path.join(dest, name))


def save_lincomb(lincomb, norm, description, output_path, name):
    nrep, neig = lincomb.shape
    columns = [description["input_hash"][:8] + "_%d" % i for i in range(1, neig + 1)]
    rows = range(1, nrep + 1)

    frame = pd.DataFrame(lincomb, columns=columns, index=rows)
    direct = frame / norm
    dirname = name + "_lincomb.csv"
    direct.to_csv(os.path.join(output_path, dirname), sep="\t", float_format="%e")

    invname = name + "_lincomb_inverse.csv"
    inverse = frame.T * norm

    inverse.to_csv(os.path.join(output_path, invname), sep="\t", float_format="%e")


def create_mc2hessian_something(pdf, Q, Neig, output_path, name=None, db=None, photon=False):
    output_path = output_path
    X = get_X(pdf, Q, reshape=True, photon=photon)
    vec = compress_X(X, Neig)
    norm = _pdf_normalization(pdf)
    description = {"input_hash": mc2h_input_hash(pdf, Q, Neig)}
    save_lincomb(vec, norm, description=description, output_path=output_path, name=name)
    return hessian_from_lincomb(pdf, vec / norm, folder=output_path, set_name=name, db=db)


def create_mc2hessian(
    pdf, Neig, output_path, sample_Q, gridnames, db=None, mc2hname=None, photon=False, installgrids=False
):
    gridpaths = []
    name=[i for i in gridnames.values()][0]
    result = create_mc2hessian_something(
        pdf, Q=sample_Q, Neig=Neig, output_path=output_path, name=name, db=db, photon=photon
    )
    gridpaths.append(result)
    if installgrids:
        install_grids(gridnames, output_path)
    return gridpaths



def make_xgrid(xminlog=1e-5, xminlin=1e-1, xmax=1, nplog=50, nplin=50):
    """Provides the points in x to sample the PDF. `logspace` and `linspace`
    will be called with the respsctive parameters."""

    return np.append(np.logspace(np.log10(xminlog), np.log10(xminlin),
                                        num=nplog, endpoint=False),
                        np.linspace(xminlin, xmax, num=nplin, endpoint=False)
                    )
        
def make_flavors(nf=3, photon=False):
    fl =  np.arange(-nf,nf+1)
    if photon:
        fl = np.r_[fl, [22]]
    return fl

def grid_values(self, pdf, Q, xgrid=None, fl=None, photon=False):

    basis='evolution'
    if Q is None:
        Q = self.QMin
    if xgrid is None:
        xgrid = make_xgrid()
    #Allow tuples that can be saved in cache
    elif isinstance(xgrid, tuple):
        xgrid = make_xgrid(*xgrid)

    if fl is None:
        fl = make_flavors()
    elif isinstance(fl, int):
        fl = make_flavors(fl)
    elif isinstance(fl, tuple):
        fl = make_flavors(*fl, photon=photon)

    pdfGrid = pdfgrids.xplotting_grid(
        pdf, Q, xgrid=xgrid, basis=basis, flavours=fl)
    pdfGrid_values = pdfGrid.grid_values

    # with self:
    #     all_members = [[[applwrap.xfxQ(r, f, x, Q)
    #                         for x in xgrid]
    #                         for f in fl]
    #                         for r in range(len(self))]

    #     all_members = np.array(all_members)
    #     mean = all_members[0]
    #     replicas = all_members[1:]
    import ipdb; ipdb.set_trace()
    return pdfGrid_values


    # checked = check_basis(basis, flavours)
    # basis = checked['basis']
    # flavours = checked['flavours']

    # if npoints == 2:
    #     xGrid = np.array([xmin, xmax])
    # else:
    #     xGrid = pdfgrids.xgrid(xmin, xmax, 'log', npoints)

    # pdfGrid = pdfgrids.xplotting_grid(
    #     pdf, Q, xgrid=xGrid, basis=basis, flavours=flavours)
    # pdfGrid_values = pdfGrid.grid_values
    # # NOTE: without this I get "setting an array element with a sequence"
    # xGrid = pdfGrid.xgrid
    # with warnings.catch_warnings():
    #     warnings.simplefilter('ignore', RuntimeWarning)
    #     alphaGrid_values = -np.log(abs(pdfGrid_values/xGrid))/np.log(xGrid)
    #     alphaGrid_values[alphaGrid_values == - np.inf] = np.nan  # when PDF_i =0
    # alphaGrid = pdfGrid._replace(grid_values=alphaGrid_values)
    # return alphaGrid