    # -*- coding: utf-8 -*-
"""
Utilities for reweighting studies

Implements utilities for calculating the NNPDF weights and unweighted PDF sets.
It also allows for some basic statistics.

Created on Mon May 30 12:50:16 2016

@author: Zahari Kassabov
"""
import logging
from collections import OrderedDict


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import lhapdf
from reportengine.table import table
from reportengine.figure import figure
from reportengine.checks import make_check
from reportengine.formattingtools import spec_to_nice_name

from validphys.core import PDF
from validphys.results import abs_chi2_data, results
from validphys import checks
from validphys import lhaindex
from validphys.lhio import new_pdf_from_indexes

log = logging.getLogger(__name__)

#TODO: implement this using reportengine expand when available
#use_t0 is to request that parameter to be set explicitly
@checks.check_pdf_is_montecarlo
def chi2_data_for_reweighting_experiments(reweighting_experiments, pdf, use_t0,
                                          t0set=None):
    return [abs_chi2_data(results(exp,pdf,t0set,)) for exp in reweighting_experiments]


def nnpdf_weights_numerator(chi2_data_for_reweighting_experiments):
    total_ndata = 0
    chi2s = np.zeros_like(chi2_data_for_reweighting_experiments[0][0].data)
    for data in chi2_data_for_reweighting_experiments:
        res, _, ndata = data
        total_ndata += ndata
        chi2s += res.data

    chi2s = np.ravel(chi2s)

    logw = ((total_ndata - 1)/2)*np.log(chi2s) - 0.5*chi2s
    logw -= np.max(logw)
    w = np.exp(logw)
    return w

@table
#will call list[0]
@checks.check_not_empty('reweighting_experiments')
def nnpdf_weights(chi2_data_for_reweighting_experiments):
    numerator = nnpdf_weights_numerator(chi2_data_for_reweighting_experiments)
    return pd.DataFrame(numerator/np.sum(numerator),
                        index=np.arange(1, len(numerator) + 1))

def effective_number_of_replicas(w):
    N = len(w)
    w = w*N/np.sum(w)
    return np.exp(np.nansum(w*np.log(N/w))/N)

@table
def reweighting_stats(pdf, nnpdf_weights, p_alpha_study):
    er = effective_number_of_replicas(nnpdf_weights)
    initial_replicas = len(pdf) - 1
    median = np.median(nnpdf_weights)
    max_alpha = p_alpha_study.argmax()

    result = OrderedDict([
                          (r'N_{initial}', initial_replicas),
                          (r'$N_{eff}$', er),
                          (r'median($w$)', median),
                          (r'$max_{[0.5,2]}P(\alpha)$', max_alpha)
                         ])

    return pd.Series(result, index=result.keys())

def p_alpha_study(chi2_data_for_reweighting_experiments):
    alphas = np.exp(np.linspace(np.log(0.5), np.log(2),31))
    vals = []
    for alpha in alphas:
        new_chi2 = [((type(res)(res.data/alpha)), central, ndata)
                    for (res,central,ndata) in
                    chi2_data_for_reweighting_experiments]
        new_ws = nnpdf_weights_numerator(new_chi2)
        val = np.sum(new_ws / alpha)
        vals.append(val)
    print(vals)
    return pd.Series(np.array(vals), index=alphas)

@figure
def plot_p_alpha(p_alpha_study):
    fig, ax = plt.subplots()
    ax.set_title(r"$P(\alpha)$")

    ax.set_yticklabels([])
    ax.set_xlabel(r'$\alpha$')


    ax.plot(p_alpha_study)
    return fig

@table
def unweighted_index(nnpdf_weights, nreplicas:int=100):
    nnpdf_weights = np.ravel(nnpdf_weights)
    res = 1 + np.random.choice(len(nnpdf_weights), size=nreplicas, p=nnpdf_weights)
    return pd.DataFrame(res, index=np.arange(1,nreplicas+1))



@make_check
def prepare_pdf_name(*, callspec, ns, environment, **kwargs):
    #TODO: Does this make any sense?
    if ns['output_path'] is not None:
        raise checks.CheckError("Output folder is not meant to be overwritten")
    output_path = environment.output_path / 'pdfsets'
    output_path.mkdir(exist_ok=True)
    ns['output_path'] = output_path

    set_name = ns['set_name']
    rootns = ns.maps[-1]
    if set_name is None:

        nreplicas = ns['nreplicas']
        set_name = spec_to_nice_name(rootns, callspec, str(nreplicas))
        ns['set_name'] = set_name

    if lhaindex.isinstalled(set_name):
        raise checks.CheckError("The PDF set that would be "
                         "generated already exists in the LHAPDF path:\n%s"
                         % lhaindex.finddir(set_name))
    if '_future_pdfs' not in rootns:
        rootns['_future_pdfs'] = {}

    future_pdfs = rootns['_future_pdfs']



    if set_name in future_pdfs:
        raise checks.CheckError("PDF set with name %s would already be "
                         "generated by another action and would be overwritten"
                         % set_name)

    lhapdf.pathsAppend(str(output_path))
    future_pdfs[set_name] = callspec



@prepare_pdf_name
@checks.check_can_save_grid
def make_unweighted_pdf(pdf, unweighted_index,
                        set_name:(str, type(None))=None, output_path=None,
                        installgrid=True):
    new_pdf_from_indexes(pdf=pdf, indexes=np.ravel(unweighted_index),
                         set_name=set_name, folder=output_path,
                         installgrid=installgrid)

    return PDF(set_name)

