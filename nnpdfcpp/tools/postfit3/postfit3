#!/usr/bin/env python
# -*- coding: utf-8 -*-
""" A script that analyses the vetoes for a completed fit"""
__authors__ = 'Nathan Hartland, Zahari Kassabov'

import os.path
import shutil
import pathlib
import argparse
from glob import glob

import lhapdf

import fitveto
from validphys import lhio
from validphys import fitdata
from validphys.core import PDF

import logging
log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
log.addHandler(ch)


def relative_symlink(source, dest):
    """ Forms a relative symlink between 'source' and 'dest' """
    relativepath = os.path.relpath(source, dest.parents[0])
    os.symlink(relativepath, dest)


def main(results, nrep):
    result_path = pathlib.Path(results).resolve()
    fitname = result_path.name
    nnfit_path = result_path / 'nnfit'
    if not fitdata.check_results_path(result_path):
        raise RuntimeError('Postfit cannot find a valid results path')
    if not fitdata.check_lhapdf_info(result_path, fitname):
        raise RuntimeError('Postfit cannot find a valid LHAPDF info file')

    nrep = int(nrep)
    log.warn("Postfit aiming for %d replicas" % nrep)

    # Setup postfit log
    postfitlog = logging.FileHandler(nnfit_path/'postfit.log', mode='w')
    log.addHandler(postfitlog)

    # Find all replicas, and filter invalid results directories
    # This glob defines what is considered a valid replica
    # all the following code uses paths from this glob
    all_replicas   = glob(f"{results}/nnfit/replica_*/")
    valid_replicas = [fitdata.check_replica_files(path, fitname) for path in all_replicas]
    valid_paths    = [all_replicas[i] for i in fitveto.mask_to_indices(valid_replicas)]
    log.info(f"{len(all_replicas)} total replicas found")
    log.info(f"{len(valid_paths)} valid replicas found")

    # Read FitInfo and compute vetoes
    fitinfo = [fitdata.load_fitinfo(pathlib.Path(path), fitname) for path in valid_paths]
    fit_vetoes = fitveto.determine_vetoes(fitinfo)

    for key in fit_vetoes:
        log.info("%d replicas pass %s" % (sum(fit_vetoes[key]), key))

    # Generate postfit and LHAPDF directory
    postfit_path = result_path/'postfit'
    LHAPDF_path = postfit_path/fitname
    if postfit_path.is_dir():
        log.warn(f"WARNING: Removing existing postfit directory: {postfit_path}")
        shutil.rmtree(str(postfit_path))
    os.mkdir(postfit_path)
    os.mkdir(LHAPDF_path)

    # Final selection
    if sum(fit_vetoes["Total"]) < nrep:
        log.warn("Number of requested replicas is too large")
        exit()
    # Select the first nrep passing replicas
    selected_replicas = fitveto.mask_to_indices(fit_vetoes["Total"])[:nrep]

    # Generate symlinks
    for drep, srep in enumerate(selected_replicas):
        # Symlink results to postfit directory
        source_dir = pathlib.Path(valid_paths[srep]).resolve()
        target_dir = postfit_path.joinpath('replica_%d' % (drep+1))
        relative_symlink(source_dir, target_dir)
        # Symlink results to pdfset directory
        source_grid = source_dir.joinpath(fitname+'.dat')
        target_file = f'{fitname}_{drep+1:04d}.dat'
        target_grid = LHAPDF_path.joinpath(target_file)
        relative_symlink(source_grid, target_grid)

    # Copy info file
    info_source_path = nnfit_path.joinpath(f'{fitname}.info')
    info_target_path = LHAPDF_path.joinpath(f'{fitname}.info')
    shutil.copy2(info_source_path, info_target_path)
    os.system(f"sed -i '' 's/REPLACE_NREP/{nrep+1}/g' {info_target_path}")

    # Generate final PDF with replica 0
    log.info("Beginning construction of replica 0")
    # It's important that this is prePended, so that any existing instance of
    # `fitname` is not read from some other path
    lhapdf.pathsPrepend(str(postfit_path))
    generatingPDF = PDF(fitname)
    lhio.generate_replica0(generatingPDF)

    # Test replica 0
    try:
        lhapdf.mkPDF(fitname, 0)
    except RuntimeError:
        log.critical("CRITICAL ERROR: Failure in reading generated replica zero")
    else:
        log.info("Postfit complete")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('nrep', nargs='?', help="Number of requested replicas")
    parser.add_argument('results', nargs='?', help="Fit results folder")
    args = parser.parse_args()
    if not all((args.results)):
        parser.error("Too few arguments: results.")
    mainargs = vars(args)
    main(**mainargs)
