#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function
""" A script that analyses the vetoes for a completed fit"""
__authors__ = 'Nathan Hartland, Zahari Kassabov'

import os.path
import shutil
import pathlib
import argparse
from glob import glob

from validphys import lhio
from validphys import fitdata
import fitveto

import logging
log = logging.getLogger(__name__)

# TODO Move to fitdata and extend {

LITERAL_FILES = ('chi2exps.log', 'nnfit.yml')
REPLICA_FILES = ('dat', 'fitinfo', 'params', 'preproc', 'sumrules')


def verify_results_path(path):
    """ Returns true if the requested path is a results directory"""
    assert path.is_dir(), 'Path is not a directory %s' % path
    assert (path / 'nnfit').is_dir(), 'Path "nnfit" is not a directory'


def verify_replica_files(path, prefix):
    """ Returns true if all required files are present in the requested
        directory """

    path = pathlib.Path(path)
    if not path.is_dir():
        log.warn("Invalid directory for replica %s" % path)
        return False
    valid = True
    for f in LITERAL_FILES:
        if not path/f:
            log.warn("Missing file: ", path/f)
            valid = False
    for f in REPLICA_FILES:
        if not path/(prefix+'.'+f):
            log.warn("Missing file: ", path/f)
            valid = False
    if not valid:
        log.warn("Found invalid replica %s" % path)
    return valid
# }


def relative_symlink(source, dest):
    """ Forms a relative symlink between 'source' and 'dest' """
    relativepath = os.path.relpath(source, dest.parents[0])
    os.symlink(relativepath, dest)


def main(results):
    result_path = pathlib.Path(results).resolve()
    verify_results_path(result_path)
    fitname = os.path.basename(results.rstrip('/'))

    # Find all replicas, and filter invalid results directories
    all_replicas   = glob(results + "/nnfit/replica_*/")
    valid_replicas = [verify_replica_files(path, fitname) for path in all_replicas]
    valid_paths    = [all_replicas[i] for i in fitveto.available(valid_replicas)]
    print(len(valid_paths), " valid replicas found")

    # Read FitInfo and compute vetoes
    fitinfo = [fitdata.load_fitinfo(pathlib.Path(path), fitname) for path in valid_paths]
    fit_vetoes = fitveto.determine_vetoes(fitinfo)

    for key in fit_vetoes:
        print(sum(fit_vetoes[key]), " replicas pass " + key)

    # Generate postfit and LHAPDF directory
    target_path = result_path/'postfit'
    LHAPDF_path = result_path/'nnfit'/fitname
    all_paths   = [target_path, LHAPDF_path]
    for path in all_paths:
        if path.is_dir():
            log.warn("WARNING: Removing existing postfit and LHAPDF directories")
            shutil.rmtree(str(path))
        os.mkdir(path)

    # Generate symlinks
    selected_replicas = fitveto.available(fit_vetoes["Total"])
    for drep, srep in enumerate(selected_replicas):
        # Symlink results to postfit directory
        source_dir = result_path.joinpath('nnfit', 'replica_%d' % (srep+1))
        target_dir = target_path.joinpath('replica_%d' % (drep+1))
        relative_symlink(source_dir, target_dir)
        # Symlink results to LHAPDF directory
        source_grid = source_dir.joinpath(fitname+'.dat')
        target_file = '%s_%04d.dat' % (fitname, drep+1)
        target_grid = LHAPDF_path.joinpath(target_file)
        relative_symlink(source_grid, target_grid)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('results', nargs='?', help="Fit results folder")
    args = parser.parse_args()
    if not all((args.results)):
        parser.error("Too few arguments: results.")
    mainargs = vars(args)
    main(**mainargs)
